## Объекты



Объекты – это ассоциативные массивы с рядом дополнительных возможностей.



Создание объекта:

```javascript
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
```



При использовании литерального синтаксиса `{...}` мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:

```javascript
let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};
```

Также можно передать литерал объекта конструктору `Object()` в качестве параметра, чтобы заполнить его свойствами / методами:

```javascript
let user = new Object({
  name: "John",
  age: 30
});
```



Использовать квадратные скобки в литеральной нотации для создания *вычисляемого свойства*:

```javascript
let fruit = "apple";
let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
```



Создание объекта внутри функции:

```javascript
function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...другие свойства
  };
}

let user = makeUser("John", 30);
```

То же самое с использованием *коротких свойств*:

```javascript
function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age,   // то же самое, что и age: age
    // ...
  };
}
```



#### Проверка существования свойства

При обращении к свойству, которого нет, возвращается `undefined`:

```javascript
let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```

Также существует специальный оператор `"in"` для проверки существования свойства в объекте:

```javascript
let user = {
    name: "John",
    age: 30,
    isAdmin: undefined
};

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
alert( "isAdmin" in user ); // true, свойство существует!
```



#### Перебор всех свойств объекта

```javascript
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```



#### Упорядочение свойств объекта

Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.



#### Методы объекта

Добавление метода с использованием функционального выражения:

```javascript
let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("Привет!");
};
```

С использованием заранее объявленной функции:

```javascript
let user = {
  // ...
};

function sayHi() {
  alert("Привет!");
}

user.sayHi = sayHi;
```

Добавление метода в литерале объекта:

```javascript
user = {
  sayHi: function() {
    alert("Привет");
  }
};
```

Ключевое слово `function` можно пропустить:

```javascript
user = {
  sayHi() {
    alert("Привет");
  }
};
```



### Функции-конструктора

Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:

1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна выполняться только с помощью оператора `"new"`.

```javascript
function User(name, age) {
    this.name = name;
    this.age = age;
}

let user = new User("John", 30);
```

Когда функция вызывается как `new User(...)`, происходит следующее:

1. Создаётся новый пустой объект, и он присваивается `this`.
2. Выполняется тело функции. Обычно оно модифицирует `this`, добавляя туда новые свойства.
3. Возвращается значение `this`.



Если в нашем коде присутствует большое количество строк, создающих один сложный объект, то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:

```javascript
// создаём функцию и сразу же вызываем её с помощью new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и инструкции
  // локальные переменные и так далее
};
```

Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся и тут же вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.
