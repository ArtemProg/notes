## Прототипы

[mdn](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Objects/Object_prototypes), [lern](https://learn.javascript.ru/prototype-inheritance), [habr](https://habr.com/ru/company/otus/blog/685528/)



Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. 



Описание проблемы: Когда мы вызываем нашу функцию-конструктор, мы определяем `greeting()` каждый раз, что не является идеальным.

```javascript
function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}

let person1 = new Person('Bob');
let person2 = new Person('Sarah');
```

Чтобы этого избежать, вместо этого мы можем определить функции на прототипе.



Для того, чтобы хранить методы только в функции-конструкторе, а в экземпляре обращаться к ним по ссылке, есть специальное свойство функции-конструктора, которое называется `prototype` — это по факту специализированное хранилище для поведения всех экземпляров, созданных функцией-конструктором.

 `prototype` — это свойство функции конструктора, которое хранит в себе интерфейс предка, к которому через ссылку `__proto__` будет обращаться потомок. 



JavaScript часто описывают как язык **прототипного наследования** — каждый объект, имеет **объект-прототип**, который выступает как шаблон, от которого объект наследует методы и свойства. Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется **цепочкой прототипов** и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.

Точнее, свойства и методы определяются в свойстве `prototype` функции-конструктора объектов, а не в самих объектах.



Значение свойства `prototype` - это объект, который в основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами, расположенными дальше по цепочке прототипов.

По умолчанию `prototype` конструктора всегда пуст.

```javascript
Person.prototype
```

Для свойства `prototype` объекта `Object` уже доступно большое количество методов, которые затем доступны для объектов, которые наследуются от `Object`:

```javascript
Object.prototype
```



### Изменение прототипов

Методы, добавленные в прототип, затем доступны для всех экземпляров объектов, созданных из конструктора.

```javascript
Person.prototype.farewell = function() {
  alert(this.name.first + ' has left the building. Bye for now!');
};
```

Вся цепочка наследования обновляется динамически, автоматически делая этот новый метод доступным для всех экземпляров объектов, полученных из конструктора.

Фактически, довольно распространённый шаблон для большего количества определений объектов - это определение свойств внутри конструктора и методов в прототипе. Это упрощает чтение кода, поскольку конструктор содержит только определения свойств, а методы разделены на отдельные блоки. 



### Прототипное наследование

Код разработчика до появления классов в ECMAScript 2015 выглядел так:

```javascript
function User(login, email) {
  this.login = login;
  this.email = email;
}

User.prototype.changeEmail = function (newEmail) {
  this.email = newEmail;
};

function Admin(login, email, team) {
  User.call(this, login, email);
  this.team = team;
}

Admin.prototype = Object.create(User.prototype);
Admin.prototype.constructor = Admin;

Admin.prototype.changeTeam = function (newTeam) {
  this.team = newTeam;
};
```





`Object.create(null)` создаёт пустой объект без прототипа (`[[Prototype]]` будет `null`).

```javascript
et dictionary = Object.create(null, {
  toString: { // определяем свойство toString
    value() { // значение -- это функция
      return Object.keys(this).join();
    }
  }
});

dictionary.apple = "Apple";
dictionary.__proto__ = "test";

// apple и __proto__ выведены в цикле
for(let key in dictionary) {
  alert(key); // "apple", затем "__proto__"
}

// список свойств, разделённых запятой, выведен с помощью toString
alert(dictionary); // "apple,__proto__"
```

