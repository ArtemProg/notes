## Модули

[mdn](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules), [learn](https://learn.javascript.ru/modules-intro), [learn](https://learn.javascript.ru/modules-dynamic-imports)



Модуль – это просто файл. Один скрипт – это один модуль.

Модули могут загружать друг друга и использовать директивы `export` и `import`, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:

- `export` отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
- `import` позволяет импортировать функциональность из других модулей.

Необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута `<script type="module"></script>`

Модули не работают локально. Только через HTTP(s). Если попытаться открыть веб-страницу локально, через протокол `file://`, то можно обнаружить, что директивы `import/export` не работают.



Особенности:

- В модулях всегда используется режим `use strict`.
- Каждый модуль имеет свою собственную область видимости.
- Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
- В модуле на верхнем уровне `this` не определён (undefined).
- Модули *всегда* выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом `defer` (описан в главе [Скрипты: async, defer](https://learn.javascript.ru/script-async-defer)).
- Для не-модульных скриптов атрибут `async` работает только на внешних скриптах. Скрипты с ним запускаются сразу по готовности, они не ждут другие скрипты или HTML-документ. Для модулей атрибут `async` работает на любых скриптах.
- В браузере `import` должен содержать относительный или абсолютный путь к модулю. Модули без пути называются «голыми» (bare). Они не разрешены в `import`.
- Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
- Старые браузеры не понимают атрибут `type="module"`. Скрипты с неизвестным атрибутом `type` просто игнорируются. Мы можем сделать для них «резервный» скрипт при помощи атрибута `nomodule`.



### Динамические импорты

Выражение `import(module)` загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.

Использовать его мы можем динамически в любом месте кода, например, так:

```javascript
let modulePath = prompt("Какой модуль загружать?");

import(modulePath)
  .then(obj => <объект модуля>)
  .catch(err => <ошибка загрузки, например если нет такого модуля>)
```

Или если внутри асинхронной функции, то можно `let module = await import(modulePath)`.

```javascript
let {hi, bye} = await import('./say.js');

hi();
bye();
```

Динамический импорт работает в обычных скриптах, он не требует указания `script type="module"`.
