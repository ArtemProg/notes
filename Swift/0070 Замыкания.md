## Замыкания (Closures)

- Ленивые свойства (lazy)

  Объявляются с lazy var. Инициализация выполняется только при полном обращении. Доступ к ленивому свойству невозможен, пока полная инициализация класса не завершена.

  ```swift
  class Example {
  		lazy var text = "Hallo"
  }
  ```

- Замыкания как свойства

  Замыкания - ссылочный тип. Если замыкание ссылается на `self`, возможен retain cycle.

  Для предотвращения утечки памяти используются `[weak self]` или `[unowned self]` в capture list.

  ```swift
  class Example {
      var closure: (() -> Void)?
  
      func setup() {
          closure = { [weak self] in
              print(self?.description ?? "nil")
          }
      }
  }
  ```

- Список захвата

  `weak` - если свойство опциональное

  `unowned` - если свойство не опциональное, гарантированно существует во время вызова замыкания.

  ```swift
  lazy var closure: () -> Void = { [unowned self] in
  		print(self.description)
  }
  ```

  

### Убегающее замыкание

Это замыкание, которое выполняется после "завершения" функции, в которую ее передали. Т.е. функция закончила работу, а замыкание еще живет и выполнится позже.

```swift
func fetchImage(from url: URL, completion: @escaping(Data) -> Void) {
    DispatchQueue.global().async {
        guard let imageData = try? Data(contentsOf: url) else { return }
        DispatchQueue.main.async {
            completion(imageData)
        }
    }
}
```

