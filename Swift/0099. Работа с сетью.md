## Работа с сетью



### URLSession

Загрузка изображения в фоновом процессе. После того, как изображение загрузилось, выполняем вывод изображения в основном потоке:

```swift
  private func fetchImage() {
      let url = URL(string: "https://img1.akspic.ru/crops/6/4/7/6/6/166746/166746-priroda-oblako-voda-rastenie-gidroresursy-1080x1920.jpg")!

      URLSession.shared.dataTask(with: url) { [weak self] data, response, error in
          guard let self else {return}
          guard let data, let response else {
              print(error?.localizedDescription ?? "No error discription")
              return
          }
          print(response)

          DispatchQueue.main.async {
              self.imageView.image = UIImage(data: data)
          }
      }.resume()
  }
```

Метод `resume` запускает задачу загрузки сетевого ресурса.



### Data

Выполняет синхронную загрузку изображения в основном потоке (блокируя основной поток во время загрузки).

```swift
  private func getImage() {

      let url = URL(string: "https://img1.akspic.ru/crops/6/4/7/6/6/166746/166746-priroda-oblako-voda-rastenie-gidroresursy-1080x1920.jpg")!

      guard let imageData = try? Data(contentsOf: url) else { return }
      imageView.image = UIImage(data: imageData)

  }
```



### DispatchQueue

Выполнение кода в основном потоке:

```swift
DispatchQueue.main.async {
    self.title = "Главный экран"
}
```

Все операции выполняемые с интерфейсом должны происходить в основном потоке.

Загрузка изображения в фоновом потоке с последующим переходом в основной поток:

```swift
private func getImage() {

    DispatchQueue.global().async {
        let url = URL(string: "https://img1.akspic.ru/crops/6/4/7/6/6/166746/166746-priroda-oblako-voda-rastenie-gidroresursy-1080x1920.jpg")!

        guard let imageData = try? Data(contentsOf: url) else { return }
        DispatchQueue.main.async { [unowned self] in
            imageView.image = UIImage(data: imageData)
            activityIndicator.stopAnimating()
        }
    }
}
```





### JSON

Парсинг json и автоматическое преобразование в экземпляр модели. Модель должна быть подписана под протокол `Codable`.

Имена свойств в модели должны полностью соответствовать написанию в файле json.

```swift
struct GroceryProduct: Codable {
    var name: String
    var points: Int
    var description: String?
}


let json = """
{
    "name": "Durian",
    "points": 600,
    "description": "A fruit with a distinctive scent."
}
""".data(using: .utf8)!


let decoder = JSONDecoder()
let product = try decoder.decode(GroceryProduct.self, from: json)


print(product.name) // Prints "Durian"
```

Если бы в json файле был бы массив элементов, то парсинг выглядел бы следующим образом:

```swift
let product = try decoder.decode([GroceryProduct].self, from: json)
```

Для более детального способа сопоставления имен используются:

```swift
// Сопоставляет ключи json в snake_case со свойствами модели в camelCase.
let decoder = JSONDecoder()
decoder.keyDecodingStrategy = .convertFromSnakeCase
```

Так же есть возможность обрабатывать более сложные случаи, создав сопоставление ключей в самой модели через перечисление `CodingKeys`:

```swift
struct GroceryProduct: Codable {
  let name: String
  let numberOfProduct: String
  
  enum CodingKeys: String, CodingKey {
    case name = "Name"
    case numberOfProduct = "Number_of_product"
  }
}
```

