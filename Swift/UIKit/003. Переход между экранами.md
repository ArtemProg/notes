## Введение

Для примера рассмотрим три простых варианта. Будем использовать две сцены.

1. **Взаимный segue**

   В `Storyboard` у нас на каждой сцене имеется кнопка с помощью которой осуществляется переход на следующую сцену `Action Segue > Show` (сцена1 -> сцена2 и сцена2 -> сцена1). 

   Сколько бы ни было совершено переходов от одной сцены к другой, каждый раз будет создаваться новый экземпляр класса, и вновь будет произведена загрузка сцены, а ее графические элементы будут добавлены в иерархию.

   

2. **Методы present и dismiss**

   Класс `UIViewController` включает в себя методы `present` и `dismiss`, которые позволяют отображать и скрывать сцены.

   При нажатии на кнопку на *сцене1* будет вызван метод `present`, которому в качестве аргумента будет передан экземпляр класса *сцена2*. После этого *сцена2* загрузится, добавится в иерархию представлений и отобразится на экране.

   При нажатии на кнопку на *сцене2* будет вызван метод `dismiss`, после чего все графические элементы *сцены2* будут убраны из иерархии, а значит *сцена2* скроется с экрана. Пользователь увидит ранее созданную *сцену1*.

   ```swift
   lazy var secondViewController: SecondViewController = getSecondViewController()
   
   private func getSecondViewController() -> SecondViewController {
       // загрузка Storyboard
       let storyboard = UIStoryboard(name: "Main", bundle: nil)
       // загрузка View Controller и его сцены со Storyboard
       let viewController = storyboard.instantiateViewController(identifier: "SecondViewController")
       return viewController as! SecondViewController
   }
   
   @IBAction func showNextScreen() {
       // отображение сцены на экране
       self.present(secondViewController, animated: true, completion: nil)
   }
   ```

   ```swift
   @IBAction func hideCurrentScene() {
       self.dismiss(animated: true, completion: nil)
   }
   ```

   

3. **Navigation Controller и segue**

   Переход между сценами с использованием навигационного контроллера и панели навигации.

   Создаем `segue` от *сцены1* к *сцене2*.

   Добавляем Navigation Controller: главное меню `Editor > Embed In > Navigation Controller`.

   В интерфейсе приложения появляется новый элемент - *панель навигации* в верхней части сцены, и при переходе на *сцену2* в ней появится кнопка для обратного перехода.

   При запуске приложения и переходе на *сцену2* и возврат к *сцене1* будут вызваны следующие методы *жизненного цикла* `View Controller`:

   ```
   loadView
   viewDidLoad
   viewWillAppear
   viewDidAppear
   # Выполняем переход
   loadView SecondViewController
   viewDidLoad SecondViewController
   viewWillDisappear
   viewWillAppear SecondViewController
   viewDidDisappear
   viewDidAppear SecondViewController
   # Возвращаемся
   viewWillDisappear SecondViewController
   viewWillAppear
   viewDidDisappear SecondViewController
   viewDidAppear
   ```
   
   При движении вперед (т.е. при переходе к следующему экрану) с помощью Navigation Controller сцена всегда загружается заново (у соответствующего View Controller вызываются методы `loadView` и `viewDidLoad`). При движении назад (т.е. при переходе к предыдущему экрану) на экран выводится уже загруженная ранее сцена.
   







## Переходы между экранами

Выбор метода зависит от типа перехода (`push` или `present`) и используемого интерфейса (`Storyboard` или `код`).



Основные способы перехода

| Метод                             | Как используется?                                       | Когда применять?                                           |
| --------------------------------- | ------------------------------------------------------- | ---------------------------------------------------------- |
| `performSegue(withIdentifier:)`   | `Storyboard` → Настроенный `Segue`                      | Когда переход задан в `Storyboard`                         |
| `pushViewController(_:animated:)` | Программно через `UINavigationController`               | Когда экран создаётся в коде и есть `NavigationController` |
| `present(_:animated:completion:)` | Программно – `Modal` (экран открывается сверху)         | Когда экран не является частью навигации                   |
| `dismiss(animated:completion:)`   | Закрывает модальный экран                               | Когда возвращаемся назад после `present()`                 |
| `popViewController(animated:)`    | Возвращает на предыдущий экран в `NavigationController` | Когда используем `pushViewController()`                    |
| `Unwind Segue`                    | `Storyboard` → Обратный переход                         | Когда нужно вернуться назад через `Storyboard`             |



| Сценарий                         | Метод перехода                    | Как передавать данные?          | Как закрывать экран?                                         |
| -------------------------------- | --------------------------------- | ------------------------------- | ------------------------------------------------------------ |
| Переход через `Storyboard`       | `performSegue(withIdentifier:)`   | `prepare(for:sender:)`          | `popViewController()` (если push) / `dismiss()` (если present) |
| Программный Push (Навигация)     | `pushViewController(_:animated:)` | Передавать напрямую в свойства  | `popViewController(animated:)`                               |
| Модальный экран (Программно)     | `present(_:animated:)`            | Передавать напрямую в свойства  | `dismiss(animated:)`                                         |
| Возврат назад через `Storyboard` | `Unwind Segue`                    | Передавать через `segue.source` | Автоматически закрывает экран                                |
| Возврат назад программно         | `delegate + popViewController()`  | `delegate` передаёт данные      | `popViewController(animated:)`                               |
| Возврат назад после `present()`  | `delegate + dismiss()`            | `delegate` передаёт данные      | `dismiss(animated:)`                                         |



### Переход через `Storyboard Segue` (`performSegue(withIdentifier:)`)

Используется, если в `Storyboard` настроен `Segue`.

```swift
performSegue(withIdentifier: "goToSecondVC", sender: nil)
```

Передача данных через `prepare(for:)`:

```swift
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if segue.identifier == "goToSecondVC",
       let secondVC = segue.destination as? SecondViewController {
        secondVC.receivedData = "Переданные данные"
    }
}
```

Когда использовать?

- Если `Storyboard` уже настроен и `Segue` создан.
- Если удобно передавать данные через `prepare(for:)`.

Когда НЕ использовать?

- Если экран создаётся программно.





### Переход через `pushViewController(_:animated:)` (Навигация)

Используется в `UINavigationController` (Push-переход).

```swift
let secondVC = SecondViewController()
secondVC.receivedData = "Переданные данные"
navigationController?.pushViewController(secondVC, animated: true)
```

Когда использовать?

- Если приложение использует `UINavigationController`.
- Если экран создаётся программно, без `Storyboard`.

Когда НЕ использовать?

- Если нет `NavigationController`.



Как вернуться назад?

```swift
navigationController?.popViewController(animated: true)
```





### Переход через `present(_:animated:completion:)` (Модальный экран)

Используется, если новый экран должен открываться сверху (Modal Presentation).

```swift
let secondVC = SecondViewController()
secondVC.modalPresentationStyle = .fullScreen // Можно убрать для стандартного перехода
present(secondVC, animated: true)
```

Когда использовать?

- Если экран не является частью навигации (`Settings`, `Login`, `Modal View`).

Когда НЕ использовать?

- Если экран является частью `UINavigationController`.



Как закрыть модальный экран?

```swift
dismiss(animated: true)
```





### Переход назад через `Unwind Segue` (`Storyboard`)

Используется в `Storyboard`, если нужно вернуться назад и передать данные.

В `FirstViewController` создаём Unwind-функцию:

```swift
@IBAction func unwindToFirstVC(_ segue: UIStoryboardSegue) {
    if let secondVC = segue.source as? SecondViewController {
        print("Полученные данные: \(secondVC.receivedData ?? "Нет данных")")
    }
}
```

В `SecondViewController` вызываем Unwind Segue:

```swift
performSegue(withIdentifier: "unwindToFirstVC", sender: self)
```

Когда использовать?

- Когда используешь `Storyboard` и `Segue`.
- Когда не хочешь настраивать `delegate`.

Когда НЕ использовать?

- Если экран создаётся программно.





### Передача данных назад через `delegate` + `dismiss`

Используется, когда передаём данные обратно при `present()` и `dismiss()`.

Создаём `protocol` в `SecondViewController`:

```swift
protocol SecondViewControllerDelegate: AnyObject {
    func didEnterData(_ data: String)
}
```

Добавляем делегата в `SecondViewController`:

```swift
class SecondViewController: UIViewController {
    weak var delegate: SecondViewControllerDelegate?
    
    var textData: String = "Данные для передачи"
    
    @IBAction func sendDataAndClose(_ sender: UIButton) {
        delegate?.didEnterData(textData)
        dismiss(animated: true)
    }
}
```

Реализуем `delegate` в `FirstViewController`:

```swift
class FirstViewController: UIViewController, SecondViewControllerDelegate {

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let secondVC = segue.destination as? SecondViewController {
            secondVC.delegate = self
        }
    }

    func didEnterData(_ data: String) {
        print("Полученные данные: \(data)")
    }
}
```

Когда использовать?

- Если экран был открыт `present()`.
- Когда важно ослабить связь между `ViewController`-ами.

Когда НЕ использовать?

- Если экран открыт `pushViewController()`.

Если `SecondViewController` открыт `pushViewController()`, используй `delegate + popViewController()`.





Передача данных между экранами туда и обратно:

- с момощью свойства
- с помощью segue/unwind
- с помощью делегата
- с помощью замыкания
- использовать ссылочные типы и метод viewWillAppear
- Работа с общим хранилищем (User Defaults,...
- Использование паттерна "Одиночка"
- Использование экземпляра класса AppDelegate
- Использование координаторов
