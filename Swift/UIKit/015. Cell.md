Прототипы ячеек

Прототип ячейки – это переиспользуемый шаблон, на основе которого создается ячейка. Прототип создается с помощью Interface Builder прямо на сцене.

Табличные представления могут содержать произвольное количество прототипов, каждый из которых может быть оформлен и использован независимо от остальных.

С помощью панели Attributes Inspector у Table View можно изменить количество прототипов в табличном представлении, измените значение поля Prototype Cells.



### Создание прототипа с использованием констрейнтов и тегов

При создании прототипа с использованием констрейнтов и тегов, в случае возникновения конфликтов в размещении графических элементов, необходимо учитывать свойство `Content Hugging Priority` расположенный на панели `Size Inspecto`.

Одним из важных свойств любого вью является наличие тегов (tag) – специальных числовых идентификаторов, по которым представление может быть найдено среди всей иерархии представлений.

Задав тег у вас появляется возможность вызвать метод `viewWithTag(tag:)`, передав в него заданное значение, и в результате получить ссылку именно на тот графический элемент, у которого указан данный тег.

```swift
view.viewWithTag(tag:1) as? UILabel
```

```swift
// ячейка на основе ограничений
private func getConfiguredTaskCell_constraints(for indexPath: IndexPath) -> UITableViewCell {
    // загружаем прототип ячейки по идентификатору
    let cell = tableView.dequeueReusableCell(withIdentifier: "taskCellConstraints", for: indexPath)

    // получаем данные о задаче, которую необходимо вывести в ячейке
    let taskType = sectionsTypesPosition[indexPath.section]
    guard let currentTask = tasks[taskType]?[indexPath.row] else {
        return cell
    }

    // текстовая метка символа
    let symbolLabel = cell.viewWithTag(1) as? UILabel
    // текстовая метка названия задачи
    let textLabel = cell.viewWithTag(2) as? UILabel

    // изменяем символ в ячейке
    symbolLabel?.text = getSymbolForTask(with: currentTask.status)
    // изменяем текст в ячейке
    textLabel?.text = currentTask.title

    // изменяем цвет текста и символа
    if currentTask.status == .planned {
        textLabel?.textColor = .black
        symbolLabel?.textColor = .black
    } else {
        textLabel?.textColor = .lightGray
        symbolLabel?.textColor = .lightGray
    }

    return cell
}

// возвращаем символ для соответствующего типа задачи
private func getSymbolForTask(with status: TaskStatus) -> String {
    var resultSymbol: String
    if status == .planned {
        resultSymbol = "\u{25CB}"
    } else if status == .completed {
        resultSymbol = "\u{25C9}"
    } else {
        resultSymbol = ""
    }
    return resultSymbol
}
```



### Создание прототипа с использованием Horizontal Stack View и кастомного класса

```swift
class TaskCell: UITableViewCell {

    @IBOutlet var symbol: UILabel!
    @IBOutlet var title: UILabel!
    
    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }

    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)

        // Configure the view for the selected state
    }

}
```

Метод awakeFromNib используется в тех случаях, когда ячейка версталась в Interface Builder, а значит ее структура хранится либо в storyboard-файле, либо в xib-файле. Как только UIKit создает экземпляр класса, соответствующего ячейке, и загружает его структуру, сразу после этого происходит вызов awakeFromNib. Данный метод может быть использован, например, для того, чтобы произвести необходимые настройки графических элементов, размещенных в ячейке.

Метод setSelected вызывается после того, как ячейка была выбрана, то есть, после того, как пользователь нажмет на нее. Данный метод можно использовать для создания различных анимаций внутри ячейки.