### Строки



**Метод Join**
Сцепляет элементы указанного массива или элементы коллекции, помещая между ними заданный разделитель.

```c#
string[] strArr = {"Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "...", "Ноябрь"};
string str = String.Join(",", strArr);
```



**Метод Split**
Создает массив подстрок, разбивая входную строку по одному или нескольким разделителям.
```c#
string str = "1,2,3,4,5";
string[] strArr = str.Split(",");
string[] arrStr = str.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
```



**Метод IsNullOrEmpty**
Указывает, действительно ли указанная строка является строкой `null` или пустой строкой ("").

```c#
string str = Console.ReadLine();
if (String.IsNullOrEmpty(str))
    Console.WriteLine("Пустая строка не допустима")
```



**Метод Trim**
Возвращает новую строку, в которой удалены все начальные и конечные вхождения заданного набора символов из текущей строки.
```c#
char[] charsToTrim = { '*', ' ', '\''};
string banner = "*** Much Ado About Nothing ***";
string result = banner.Trim(charsToTrim);
Console.WriteLine("Trimmmed\n   {0}\nto\n   '{1}'", banner, result);

// The example displays the following output:
//       Trimmmed
//          *** Much Ado About Nothing ***
//       to
//          'Much Ado About Nothing'
```



**Метод ToLower**
Возвращает копию этой строки, переведенную в нижний регистр.
```c#
string str = "Верхний Регистр".ToLower();
```



**Метод Format**
Преобразует значения объектов в строки на основе указанных форматов и вставляет их в другую строку.
```c#
string s = String.Format("At {0}, the temperature is {1}°C.",
                         DateTime.Now, 20.4);
Console.WriteLine(s);
// Output similar to: 'At 4/10/2015 9:29:41 AM, the temperature is 20.4°C.'
```



**Метод Concat**
Объединяет один или несколько экземпляров класса String или представления в виде String значений одного или нескольких экземпляров Object.
```c#
using System;

public class Example
{
   public static void Main()
   {
      String s1 = "We went to a bookstore, ";
      String s2 = "a movie, ";
      String s3 = "and a restaurant.";

      var s = String.Concat(s1, s2, s3);
      Console.WriteLine(s);
   }
}
// The example displays the following output:
//      We went to a bookstore, a movie, and a restaurant.
```



**Напомните еще раз, что означают символы \n и \t.**
Это так называемые esc-последовательности. \n — перенос строки, \t — табуляция, \r — символ возврата. В текстовых файлах Windows строки должны заканчиваться символами \r\n (об этом мы говорили в главе 8 при знакомстве с константой Environment.NewLine). Чтобы использовать в строке обратную косую черту, которую компилятор не воспринимает как esc-последовательность, делайте ее двойной: \\.



 **Зачем нужен знак @ перед именем файла?**
При добавлении в программу строковых констант компилятор преобразует esc-последовательности (\n или \r) в специальные символы. Но косая черта присутствует и в маршрутах доступа к файлам. Поместив в начало строки знак @, вы говорите C#, что в строке отсутствуют esc-последовательности. Кроме того, в нее начинают включаться знаки переноса (то есть нажатия клавиши Enter фиксируются автоматически):
```c#
string twoLine = @"это строка,
занимающая две строчки.";
```



**Интерполяция строк**
Специальный знак $ идентифицирует строковый литерал как интерполированную строку. Интерполированная строка — это строковый литерал, который может содержать выражения интерполяции. При разрешении интерполированной строки в результирующую элементы с выражениями интерполяции заменяются строковыми представлениями результатов выражений.
```c#
string name = "Иванов";
string position = "Менеджер";
Console.WriteLine($"Сотрудник: {name}, должность: {position}"); // Сотрудник: Иванов, должность: Менеджер
```



> Начиная с C# 8.0 маркеры $ и @ можно использовать в любом порядке: $@"..." и @$"..." являются допустимыми интерполированными строками verbatim. В более ранних версиях C# маркер $ должен располагаться перед маркером @.