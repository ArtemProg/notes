## Атрибуты

Атрибут — это фрагмент информации, который можно присоединить к классу, переменной или методу



##### SerializeField и HideInInspector

Атрибут `[SerializeField]` позволяет отобразить в инспекторе поля со спецификатором `private`.

Атрибут `[HideInInspector]` позволяет скрыть в инспекторе поля со спецификатором `public`.

```c#
class Monster : MonoBehaviour {
 // Появится в инспекторе, потому что общедоступная
 // Доступна другим сценариям
 public int hitPoints;
 // Не появится в инспекторе, потому что приватная
 // Недоступна другим сценариям
 private bool isAlive;
 // Появится в инспекторе благодаря атрибуту SerializeField
 // Недоступна другим сценариям
 [SerializeField]
 private int magicPoints;
 // Не появится в инспекторе благодаря атрибуту HideInInspector
 // Доступна другим сценариям
 [HideInInspector]
 public bool isHostileToPlayer;
}
```



##### RequireComponent

Тип требуемого компонента передается в параметре, например:

```c#
[RequireComponent(typeof(Animator))]
class ClassThatRequiresAnAnimator : MonoBehaviour {
 // этот класс требует предварительного подключения компонента
 // Animator к игровому объекту GameObject
}
```



##### Header и Space

Атрибут Header, когда присоединяется к полю, заставляет Unity выводить указанную надпись над полем в инспекторе. Атрибут Space действует аналогично, но добавляет пустое пространство. Оба атрибута удобно использовать для визуальной организации содержимого в инспекторе.

```c#
public class Spaceship : MonoBehaviour {
 [Header("Spaceship Info")]
 public string name;
 public Color color;
 [Space]
 public int missileCount;
}
```



##### ExecuteInEditMode

По умолчанию код сценариев выполняется только в режиме проигрывания, то есть код в вашем методе Update выполнится только после запуска игры. Однако иногда бывает удобно иметь код, выполняющийся все время. Если это ваш случай, добавьте к своему классу атрибут ExecuteInEditMode.

> Жизненный цикл компонента в режиме редактирования протекает иначе, чем в режиме проигрывания. В режиме редактирования Unity перерисовывает себя только тогда, когда это действительно необходимо, обычно в ответ на ввод пользователя, такой как щелчки мышью. Это означает, что метод Update будет выполняться лишь изредка. Кроме того, сопрограммы в этом режиме действуют не так, как ожидается. Помимо этого, вы не сможете вызвать Destroy в режиме редактирования, потому что Unity откладывает фактическое удаление до следующего кадра. Вместо него в режиме редактирования следует вызывать метод DestroyImmediate, который удаляет объект немедленно.

Например, вот сценарий, который удерживает объект всегда повернутым лицом к цели, даже в режиме редактирования:

```c#
[ExecuteInEditMode]
class LookAtTarget : MonoBehaviour {
    public Transform target;
    void Update() {
        // Не продолжать, если нет цели
        if (target != null) {
            return;
        }
        // Повернуть лицом к цели
        transform.LookAt(target);
    }
}
```

