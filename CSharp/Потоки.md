## Потоки (Threads)



Многозадачность на основе *процессов* позволяет выполнять одновременно более одной программы в контексте операционной системы.

Многозадачность на основе *потоков* означает параллельное выполнение отдельных частей программы.



**System.Threading** - Пространство имен для работы с потоками, содержит, классы для управления потоками, такие как: *Thread*, *ThreadStart*, *ParameterizedThreadStart*, *Monitor*.



### Потоки без параметров

```c#
static void WriteSecond()
{
    while (true)
    {
        Console.WriteLine(new string(' ', 10) + "Secondary");
    }
}

ThreadStart writeSecond = new ThreadStart(WriteSecond); // Создание делегата
Thread thread = new Thread(writeSecond);
thread.Start();

WriteSecond();
```



Создание потока используя технику предположения делегата:

```c#
static void WriteSecond()
{
    int counter = 0;
    while (counter < 10)
    {
        Console.WriteLine("Thread Id {0}, counter = {1}", Thread.CurrentThread.GetHashCode(), counter);
        counter++;
    }
}

// Работа вторичного потока
Thread thread = new Thread(WriteSecond);
thread.Start();

// Работа первичного потока
WriteSecond();
```



### Передача параметров в поток

```c#
static void WriteSecond(object argument)
{
    for (int i = 0; i < 10; i++)
    {
        Console.WriteLine(argument);
        Thread.Sleep(1000);
    }
}

ParameterizedThreadStart writeSecond = new ParameterizedThreadStart(WriteSecond);
Thread thread = new Thread(writeSecond);
thread.Start("Hello");

// И так тоже можно
Thread thread = new Thread(WriteSecond);
thread.Start("Hello");
```



### Запуск в потоке анонимных методов, использование замыкания:

```c#
void Main()
{
    int counter = 0;

    // Замыкание
    Thread thread = new Thread(delegate() { Console.WriteLine("1. counter = {0}", ++counter); } );
    thread.Start();

    Thread.Sleep(100);
    Console.WriteLine("2. counter = {0}", counter);

    // ParameterizedThreadStart
    thread = new Thread((object argument) => { Console.WriteLine("3. counter = {0}", (int)argument); } );
    thread.Start(counter);
}
```



### Завершение работы вторичного потока

```c#
thread.IsBackground = true;
```



### Техника синхронизации доступа к разделяемому ресурсу

`lock` - блокирует блок кода так, что в каждый отдельный момент времени, этот блок кода сможет использовать только один поток. Все остальные потоки ждут пока текущий поток, закончит работу.

```c#
object block = new object(); // Объект блокировки / Объект синхронизации доступа к разделяемому ресурсу

public void Method()
{
	lock(block) // Критическая секция
	{
		for (int count = 0; count < 10; count++)
		{
			Console.WriteLine("Counter = {0}", counter);
            Thread.Sleep(200);
		}
	}
}

for (int i = 0; i < 3; i++)
{
    new Thread(Method).Start(); // Создание потоков
}
```



`lock` - это сокращенное использование `System.Monitor`.

`Monitor.Enter(this)` - блокирует блок кода так, что его может использовать только текущий поток. Все остальные потоки ждут пока текущий поток, закончит работу и вызовет `Monitor.Exit(this)`.

```c#
object block = new object(); // Объект блокировки

public void Method()
{
	Monitor.Enter(block); // Критическая секция
	
    for (int count = 0; count < 10; count++)
    {
        Console.WriteLine("Counter = {0}", counter);
        Thread.Sleep(200);
    }
    
	Monitor.Exit(block);
}

for (int i = 0; i < 3; i++)
{
    new Thread(Method).Start(); // Создание потоков
}
```

