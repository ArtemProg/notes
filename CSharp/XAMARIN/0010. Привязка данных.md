

## Привязка данных

[ms learn](https://docs.microsoft.com/ru-ru/learn/modules/separate-your-ui-and-code-with-xamarin-forms-data-binding/2-use-databinding-in-xamarin-forms)



Объект *binding* связывает два свойства. Одно свойство находится в пользовательском интерфейсе, а другое — в объекте модели данных. При изменении значения любого из этих свойств объект привязки может обновлять другое свойство. Другими словами, привязки — это промежуточные объекты, которые синхронизируют ваши данные и пользовательский интерфейс. Термины *исходный* и *целевой* мы используем для определения двух участвующих объектов.

Правила для исходного и целевого объекта различаются:

- **Источник**. Источник: может быть объектом любого типа. На практике в качестве исходного объекта обычно используется объект данных C#. Для участия в привязке вам нужно определить свойство для этого исходного объекта. Свойство определяется путем задания `Path` в привязке.
- **Целевой объект**. Целевой объект должен быть производным от `BindableObject`. Целевое свойство должен быть реализовано с помощью специального свойства с именем `BindableProperty`. Все элементы управления Xamarin.Forms в конечном счете являются производными от `BindableObject` (через `View`). Их свойства в основном являются `BindableProperties`. Такая архитектура обеспечивает использование всех элементов управления Xamarin.Forms в качестве удобных целевых объектов привязки.



### Создание привязок данных в XAML

Пример привязки в XAML с помощью расширения разметки `{Binding}`

```xaml
<!-- In XAML our bindings do not need to set Source -->
<StackLayout Padding="20" Spacing="20">
    <StackLayout.Resource>
        <ResourceDictionary>
            <Todo x:Kye="getMilk" Title="Pickup some Milk" />
        </ResourceDictionary>
    </StackLayout.Resource>
    <Entry Text="{Binding Title, Source={StaticResource getMilk}}" />
</StackLayout>
```

Для исходного объекта:

- Объект создается в словаре ресурсов страницы с `Key` из `getMilk`.
- Значение параметра `Path` — `Title`.

Для целевого объекта:

- Объект является элементом управления `Entry`.
- Свойство имеет значение `Text`.

При загрузке этого файла XAML расширение разметки `{Binding}` создает привязку между `Todo` и `Entry`. Объект привязки считывает `Todo.Title` и загружает значение в `Entry.Text`.



### Создание привязок данных в коде

Этот метод может быть удобен при динамическом создании пользовательского интерфейса.

```c#
// Create Source
ToDo task = new ToDo() { Title = "Pickup some Milk", ... };

// Create target
Entry Name = new Entry();

// Create binding, identifying Source and Path
Binding nameBinding = new Binding()
nameBinding.Source = task;
nameBinding.Path = "Title";

// Set Binding, identifying Target object and Target property
Name.SetBinding(Entry.TextProperty, nameBinding);
```



### Использование одного источника для нескольких привязок

Класс `BindableObject` определяет свойство с именем `BindingContext`. Все страницы, панели макета и элементы управления Xamarin.Forms наследуют от `BindableObject`, таким образом, данное свойство есть у всех этих элементов.

При создании привязки параметр `Source` является необязательным. Привязка без параметра для `Source` автоматически ищет в визуальном дереве свойства `BindingContext`, значение которых отлично от NULL.

```xaml
<Picker x:Name="country" />
```

```c#
private void InitializeData()
{
    // country.SelectedItem = CurrentFlag.Country;
    // country.SelectedIndexChanged += (s, e) => CurrentFlag.Country = repository.Countries[country.SelectedIndex];
    country.BindingContext = CurrentFlag;
    country.SetBinding(Picker.SelectedItemProperty, new Binding(nameof(CurrentFlag.Country)));
    ...
}
```



`BindingContext`, как правило, задается на уровне страницы. Наши привязки XAML содержат только исходный путь, что помогает уменьшить размеры кода XAML и сделать его более удобным для чтения.

```c#
// In code-behind we set Page.BindingContext
BindingContext = new Todo() { Title = "Pickup some milk", Notes = "Stop at the Grocery Store!", Completed = true }
```

```xaml
<!-- In XAML our bindings do not need to set Source -->
<StackLayout Padding="20" Spacing="20">
    <Entry Text="{Binding Title}" />
    <Entry Text="{Binding Notes}" />
    <Switch IsToggled="{Binding Completed}" />
</StackLayout>
```

Привязки отслеживают изменения в *ссылке на объект* своего источника. Эта функция работает даже для привязок, использующих `BindingContext` в качестве источника. Если `Source` или `BindingContext` переназначается другому объекту, привязка получает данные из нового источника и обновляет целевой объект.

Также можно удалить атрибуты `x:Name` из всех объектов XAML, которые теперь привязаны. Частное поле, сопоставленное с элементом управления, теперь удаляется, что упрощает работу с IntelliSense.



## Настройка определенных возможностей для привязок данных



Не всем привязкам данных нужны одни и те же возможности. Нужно выбрать такое поведение, которое позволяет свести к минимуму сложность кода и нагрузку на обработчик. Вы можете использовать две операции:

- копирование в пользовательский интерфейс при изменении данных кода программной части;
- копирование в код программной части при изменении пользовательского интерфейса.



### Односторонние и двусторонние привязки

*Односторонняя привязка* передает данные только от исходного в целевой объект. Помните, что источником обычно является объект кода программной части. Предположим, в источнике есть свойство, которое привязано к `Label`. Очевидно, что данные из источника нужно загрузить в `Label`. Однако есть ли необходимость отправлять данные обратно в другом направлении? Это даже не имеет смысла для `Label`. Пользователь не может изменять значение. В этой ситуации однозначно используется односторонняя привязка.

*Двусторонняя привязка* отправляет данные в обоих направлениях между исходным и целевым объектом. Рассмотрим привязку исходного свойства к элементу управления `Entry`. Этот вариант отличается от примера `Label`, так как пользователь может изменять значение в `Entry`. Вам нужно записать введенные пользователем данные и перенести их в объект данных кода программной части. В этой ситуации используется двусторонняя привязка.



### Режим привязки

*Режим* привязки определяет, является ли она односторонней или двусторонней. Любая создаваемая привязка может быть одно- или двусторонней. Это определяется параметром, выбранным для свойства `Mode` объектов `Binding`. В примере кода ниже показано, как явно задать режим:

```xaml
<Label Text="{Binding Title, Mode=OneWay}" />
<Entry Text="{Binding Notes, Mode=TwoWay}" />
```



### Как привязка узнает об изменении исходного объекта?

Решением будет написание кода, который вызывает событие при изменении любого из исходных свойств. Вам потребуется реализовать интерфейс `INotifyPropertyChanged` для класса источника. Интерфейс имеет один член — событие с именем `PropertyChanged`. Привязки автоматически находят этот интерфейс в исходном объекте и подписываются на событие.

Обработчик событий привязки проверяет, соответствует ли переданное имя свойства свойству `Path` привязки. Другими словами, является ли это событие уведомлением для свойства, за которое отвечает эта привязка? Если да, привязка считывает новое значение свойства и обновляет пользовательский интерфейс.



## Создание привязок с несовпадающими типами



Иногда данные не точно соответствуют типу данных элемента управления пользовательского интерфейса. Например, может присутствовать значение типа `double`, которое нужно отобразить как валюту в `Label`. Более сложным примером будет URL-адрес изображения в данных, который должен отображать реальное изображение в пользовательском интерфейсе.



### Форматирование строк в привязке

Предположим, вы хотите отобразить это свойство в пользовательском интерфейсе (Пример текста: "You Owe: $15.83"):

```c#
public double BillAmount { get; set; }
```

С помощью свойства `StringFormat` привязки можно вызвать `String.Format`. Для строки формата действуют те же правила, что и для метода `String.Format`. Заключите строку формата в одинарные кавычки, чтобы средство синтаксического анализа XAML не столкнулось с проблемами при обработке фигурных скобок. В своем примере мы хотим получить формат валюты, поэтому используем следующую привязку:

```xaml
<Label Text="{Binding BillAmount, StringFormat='You Owe: {0:C}'}"/>
```



### Преобразование пользовательских типов

Если вы преобразуете значение во что-то типа `Color` или `Image`, нужно написать код пользовательского преобразования.

Предположим, например, что в ваших данных есть свойство с именем `PasswordStrength` типа `PasswordStrengthEnum`. Вы хотите использовать `PasswordStrength` для управления цветами в пользовательском интерфейсе. Ненадежный пароль отображается красным цветом, а надежный — зеленым. Напишите код преобразования для сопоставления значения `PasswordStrengthEnum` с `Color`.

Следующий код пока не будет работать, но он демонстрирует цель. Обратите внимание на несоответствие типов: `PasswordStrength` имеет тип `PasswordStrengthEnum`, тогда как `BackgroundColor` является `Color`.

```xaml
<Entry BackgroundColor="{Binding PasswordStrength}" ... />
```

Xamarin.Forms предоставляет стандартный способ упаковки и применения этого кода преобразования типов:

- Код преобразования переходит в класс, реализующий интерфейс `IValueConverter`.
- Вы применяете преобразователь с помощью свойства `Converter` привязки.



#### Реализация IValueConverter

Преобразователи рекомендуется реализовывать как автономные служебные классы. Большинство разработчиков используют имя класса, который заканчивается на `Converter`, чтобы явно указать на его назначение.

У интерфейса `IValueConverter` имеется два метода:

- `Convert`: преобразует данные кода программной части в значение пользовательского интерфейса. 
- `ConvertBack`: преобразует значения пользовательского интерфейса в данные кода программной части. Этот метод требуется не так часто. Большинство преобразователей создают исключение `NotSupportedException` для указания того, что он не реализован.

Метод `Convert` принимает четыре параметра. Вот его сигнатура:

```c#
public object Convert(object value, Type targetType, object parameter, CultureInfo culture);
```

Ниже приведен пример простой реализации преобразователя:

```c#
public class PasswordStrengthToColorConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        var strength = (PasswordStrengthEnum)value;

        if (strength == PasswordStrengthEnum.Strong)
            return Color.Green;
        else
            return Color.Red;
    }
    ...
}
```



#### Создание экземпляра преобразователя

Создайте экземпляр преобразователя. Экземпляр должен быть доступен в вашем XAML-коде, чтобы его можно было применять в привязках. Стандартный способ создания экземпляра преобразователя это добавление его в словарь ресурсов `Page`.

Во-первых, нужно определить префикс, который соответствует пространству имен кода программной части, содержащему класс преобразователя. Пример кода приведен ниже.

```xaml
<ContentPage ... xmlns:cvt="clr-namespace:MyProject.MyConverters">
```

Затем вам нужно создать экземпляр преобразователя в словаре ресурсов.

```xaml
<Page.Resources>
    <cvt:PasswordStrengthToColorConverter x:Key="pwcolorConverter" />
</Page.Resources>
```



#### Применение преобразователя в привязке

Свойство `Converter` привязки используется для применения преобразователя типов. Как правило, экземпляр преобразователя находится в словаре ресурсов, поэтому для доступа к нему используйте `StaticResource`.

Пример такой задачи приведен в следующем коде. Привязка автоматически вызывает метод `Convert`, а также передает `PasswordStrength` как `value` и `Color` как `targetType`.

```xaml
<Entry BackgroundColor="{Binding PasswordStrength, Converter={StaticResource pwcolorConverter}}" ... />
```

