# Внедрение зависимости (Dependency Injection)



Ссылки:

- [Книга "Шаблоны корпоративного приложения"](https://docs.microsoft.com/ru-ru/xamarin/xamarin-forms/enterprise-application-patterns/dependency-injection)
- [ms learn](https://docs.microsoft.com/ru-ru/learn/modules/explore-cross-platform-design-patterns/10-use-an-ioc-container-to-automatically-inject-dependencies?ns-enrollment-type=LearningPath&ns-enrollment-id=learn-xamarin.customize-your-xamarin-forms-apps)
- [Разрешение зависимостей в Xamarin.Forms](https://docs.microsoft.com/ru-ru/xamarin/xamarin-forms/internals/dependency-resolution)
- [Xamarin.Forms - Dependency Service](https://docs.microsoft.com/en-us/samples/xamarin/xamarin-forms-samples/dependencyservice/)
- [Xamarin.Forms DependencyService](https://docs.microsoft.com/ru-ru/xamarin/xamarin-forms/app-fundamentals/dependency-service/)



> Как правило, конструктор класса вызывается при создании экземпляра объекта, а все значения, необходимые объекту, передаются в конструктор в качестве аргументов. Это пример внедрения зависимостей, который, в частности, называется *внедрением конструктора*. Зависимости, необходимые объекту, вставляются в конструктор.
>
> Указывая зависимости как типы интерфейсов, внедрение зависимостей позволяет разделять конкретные типы от кода, зависящего от этих типов. Обычно используется контейнер, содержащий список регистраций и сопоставлений между интерфейсами и абстрактными типами, а также конкретные типы, реализующие или расширяющие эти типы.
>
> Существуют также другие типы внедрения зависимостей, такие как *внедрение свойства* и *внедрение вызова метода*, но они являются менее часто используемыми.



Процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» (англ. Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

При использовании паттерна «внедрение зависимости» объект пассивен и не предпринимает вообще никаких шагов для выяснения зависимостей, а предоставляет для этого сеттеры и/или принимает своим конструктором аргументы, посредством которых внедряются зависимости.



### IoC-контейнеры

Они помогают уменьшить количество рутины, позволяя задать соответствие между интерфейсом и его конкретной реализацией, чтобы потом везде этим пользоваться.



## Внедрение зависимостей

Внедрение зависимостей представляет собой специализированную версию шаблона инверсии управления (IoC), где отзываемая проблема — это процесс получения необходимой зависимости. При внедрении зависимостей другой класс отвечает за внедрение зависимостей в объект во время выполнения.

В следующем примере кода показано, как структурирован класс `ProfileViewModel` при использовании внедрения зависимостей.

```c#
public class ProfileViewModel : ViewModelBase  
{  
    private IOrderService _orderService;  

    public ProfileViewModel(IOrderService orderService)  
    {  
        _orderService = orderService;  
    }  
    ...  
}
```

Конструктор получает `IOrderService` экземпляр в качестве аргумента, который внедряется другим классом. Единственная зависимость в `ProfileViewModel` классе относится к типу интерфейса. Таким образом, `ProfileViewModel` класс не имеет сведений о классе, который отвечает за создание экземпляра `IOrderService` объекта. 

Контейнеры внедрения зависимостей уменьшают взаимосвязь между объектами, предоставляя возможность создавать экземпляры классов и управлять временем существования в зависимости от конфигурации контейнера. Во время создания объектов контейнер внедряет все зависимости, необходимые объекту. Если эти зависимости еще не созданы, контейнер сначала создает и разрешает их зависимости.

> Внедрение зависимостей также может быть реализовано вручную с помощью фабрик. Однако использование контейнера предоставляет дополнительные возможности, такие как управление жизненным циклом и регистрация через сканирование сборок.

Использование контейнера внедрения зависимостей имеет несколько преимуществ.

- Контейнер устраняет необходимость класса для определения его зависимостей и управления временем существования.
- Контейнер позволяет сопоставлять реализованные зависимости, не влияя на класс.
- Контейнер упрощает тестирование, позволяя макетирование зависимостей.
- Контейнер повышает удобство поддержки, позволяя легко добавлять новые классы в приложение.

В контексте Xamarin.Forms приложения, использующего MVVM, контейнер внедрения зависимостей обычно используется для регистрации и разрешения моделей представлений, а также для регистрации служб и их внедрения в модели представления.

Во время выполнения контейнер должен быть уверен, какую реализацию `IOrderService` интерфейса он должен создавать, прежде чем он сможет создать экземпляр `ProfileViewModel` объекта. Сюда входит:

- Контейнер, который решает, как создать экземпляр объекта, реализующего `IOrderService` интерфейс. Это называется *регистрацией*.
- Контейнер, создающий экземпляр объекта, который реализует `IOrderService` интерфейс, и `ProfileViewModel` объект. Это называется *разрешением*.

В конечном итоге приложение завершит использование `ProfileViewModel` объекта и станет доступным для сборки мусора. На этом этапе сборщик мусора должен удалить `IOrderService` экземпляр, если другие классы не используют один и тот же экземпляр.



### Регистрация

Прежде чем можно будет внедрить зависимости в объект, необходимо сначала зарегистрировать типы зависимостей в контейнере. Регистрация типа обычно подразумевает передачу в контейнер интерфейса и конкретного типа, реализующего интерфейс.

Существует два способа регистрации типов и объектов в контейнере с помощью кода:

- Зарегистрируйте тип или сопоставление с контейнером. При необходимости контейнер будет строить экземпляр указанного типа.
- Зарегистрируйте существующий объект в контейнере как одноэлементный. При необходимости контейнер вернет ссылку на существующий объект.

> Контейнеры внедрения зависимостей не всегда подходят. Внедрение зависимостей предоставляет дополнительные сложности и требования, которые могут быть нецелесообразными или полезными для небольших приложений. Если у класса нет зависимостей или он не зависит от других типов, он может не иметь смысла размещать его в контейнере. Кроме того, если класс содержит один набор зависимостей, которые являются неотъемлемой частью типа и никогда не изменяются, может не иметь смысла размещать его в контейнере.

Регистрация типов, требующих внедрения зависимостей, должна выполняться в одном методе в приложении, и этот метод должен вызываться на раннем этапе жизненного цикла приложения, чтобы гарантировать, что приложение знает о зависимостях между его классами.



Пример регистрации:

- При запуске приложения

```c#
public partial class App : Application
{
    public App()
    {
        InitializeComponent();
        DependencyService.Register<ICoffeeService, CoffeeService>();
        ...
    }
}
```

- Будет произведена регистрация всех реализуемых интерфейзов за конкретным классом

```c#
using Xamarin.Forms;
using MyCoffeeApp.Services;

[assembly: Dependency(typeof(CoffeeService))]
namespace MyCoffeeApp.Services
{
    public class CoffeeService : ICoffeeService
    {
        ...
    }
}
```

Пример использования:

```c#
ICoffeeService coffeeService;
...
coffeeService = DependencyService.Get<ICoffeeService>();
...
await coffeeService.RemoveCoffee(coffee.Id);
...
DependencyService.Get<IToast>()?.MakeToast("Refreshed!");
```

